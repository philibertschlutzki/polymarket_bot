import logging
import os
from datetime import datetime, timedelta, timezone

import asciichartpy
from dateutil import parser

from src import database

logger = logging.getLogger(__name__)

# Try to get CET timezone
try:
    from zoneinfo import ZoneInfo

    CET_TZ = ZoneInfo("Europe/Berlin")
except ImportError:
    # Fallback to fixed offset (UTC+1) if zoneinfo is not available
    CET_TZ = timezone(timedelta(hours=1))


def to_cet(dt):
    """Converts a datetime to CET/CEST."""
    if dt is None:
        return None
    if isinstance(dt, str):
        try:
            dt = parser.parse(dt)
        except Exception:
            return None

    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)

    return dt.astimezone(CET_TZ)


def generate_dashboard():
    """Generates the complete Performance Dashboard Markdown file."""
    logger.info("Generating dashboard...")

    # 1. Load Data
    capital = database.get_current_capital()
    metrics = database.calculate_metrics()
    active_bets = database.get_active_bets()
    pending_bets = database.get_all_unresolved_bets()
    for b in pending_bets:
        b["status"] = "PENDING_RESOLUTION"
        if "expected_value" not in b:
            b["expected_value"] = 0.0
    all_active_display = active_bets + pending_bets
    results = database.get_all_results()
    last_run = database.get_last_run_timestamp()
    now_cet = datetime.now(CET_TZ)

    # Generate sections
    header = _generate_header(capital, metrics, now_cet)
    system_status = _generate_system_status(last_run, now_cet)
    gemini_usage, rpm_pct, rpd_pct, tpm_pct = _generate_gemini_usage()
    performance_metrics = _generate_performance_metrics(results, metrics)
    risk_metrics = _generate_risk_metrics(active_bets, capital)
    active_bets_section = _generate_active_bets_section(all_active_display, now_cet)
    alerts_section = _generate_alerts_section(rpm_pct, rpd_pct, tpm_pct, active_bets, capital, now_cet)
    market_insights = _generate_market_insights(all_active_display)
    chart_section = generate_chart_section(results)
    recent_section = generate_recent_results_section(results)
    advanced_analytics_section = generate_advanced_analytics_section(results)

    # Assembly
    content = (
        header
        + system_status
        + gemini_usage
        + performance_metrics
        + risk_metrics
        + active_bets_section
        + alerts_section
        + market_insights
        + advanced_analytics_section
        + chart_section
        + recent_section
        + "\n*Generated by Polymarket AI Bot v2.0*\n"
    )

    with open("PERFORMANCE_DASHBOARD.md", "w", encoding="utf-8") as f:
        f.write(content)

    database.update_last_dashboard_update()
    logger.info("âœ… Dashboard generated successfully.")


def _generate_header(capital, metrics, now_cet):
    total_return_usd = metrics["total_return_usd"]
    total_return_pct = metrics["total_return_percent"] * 100
    return f"""# ğŸ“Š Polymarket AI Bot - Performance Dashboard

**Last Updated:** {now_cet.strftime('%Y-%m-%d %H:%M:%S %Z')}
**Current Capital:** ${capital:,.2f} USDC
**Total Return:** {total_return_pct:+.2f}% (${total_return_usd:+.2f})

---
"""


def _generate_system_status(last_run, now_cet):
    if last_run:
        last_run_cet = to_cet(last_run)
        next_run_cet = last_run_cet + timedelta(minutes=15)
        time_until_next = (next_run_cet - now_cet).total_seconds()

        if time_until_next > 0:
            bot_status = "ğŸŸ¢ Active"
        elif time_until_next > -60:
            bot_status = "ğŸŸ¡ Running"
        else:
            bot_status = "ğŸ”´ Delayed"

        last_run_str = last_run_cet.strftime("%Y-%m-%d %H:%M:%S %Z")
        next_run_str = next_run_cet.strftime("%Y-%m-%d %H:%M:%S %Z")
    else:
        bot_status = "âšª Unknown"
        last_run_str = "N/A"
        next_run_str = "N/A"

    return f"""## â° System Status

| Metric | Value |
|--------|-------|
| Last Run | {last_run_str} |
| Next Run | {next_run_str} |
| Run Interval | 15 minutes |
| Bot Status | {bot_status} |

---
"""


def _generate_gemini_usage():
    rpm = database.get_api_usage_rpm("gemini")
    rpd = database.get_api_usage_rpd("gemini")
    tpm = database.get_api_usage_tpm("gemini")

    LIMIT_RPM = 15
    LIMIT_RPD = 1500
    LIMIT_TPM = 1000000

    rpm_pct = (rpm / LIMIT_RPM) * 100
    rpd_pct = (rpd / LIMIT_RPD) * 100
    tpm_pct = (tpm / LIMIT_TPM) * 100

    def usage_indicator(pct):
        if pct >= 90:
            return "ğŸ”´"
        elif pct >= 70:
            return "ğŸŸ¡"
        else:
            return "ğŸŸ¢"

    usage_section = f"""## ğŸ¤– Gemini API Usage

| Period | Calls/Tokens | Limit | Usage | Status |
|--------|--------------|-------|-------|--------|
| Current Minute (RPM) | {rpm} | {LIMIT_RPM} | {rpm_pct:.0f}% | {usage_indicator(rpm_pct)} |
| Today (RPD) | {rpd} | {LIMIT_RPD:,} | {rpd_pct:.1f}% | {usage_indicator(rpd_pct)} |
| Current Minute (TPM) | {tpm:,} | {LIMIT_TPM:,} | {tpm_pct:.2f}% | {usage_indicator(tpm_pct)} |

---
"""
    return usage_section, rpm_pct, rpd_pct, tpm_pct


def _generate_performance_metrics(results, metrics):
    wins = sum(1 for r in results if r["profit_loss"] > 0)
    losses = len(results) - wins

    return f"""## ğŸ“ˆ Performance Metrics

| Metric | Value |
|--------|-------|
| Total Bets | {len(results)} |
| Win Rate | {metrics['win_rate']*100:.2f}% ({wins}W / {losses}L) |
| Avg ROI per Bet | {metrics['avg_roi']*100:+.1f}% |
| Sharpe Ratio | {metrics['sharpe_ratio']:.2f} |
| Max Drawdown | {metrics['max_drawdown']*100:.1f}% |
| Best Bet | ${metrics['best_bet_usd']:+.2f} |
| Worst Bet | ${metrics['worst_bet_usd']:+.2f} |

---
"""


def _generate_risk_metrics(active_bets, capital):
    total_exposure = sum(b["stake_usdc"] for b in active_bets)
    exposure_pct = (total_exposure / capital * 100) if capital > 0 else 0
    avg_position = total_exposure / len(active_bets) if active_bets else 0
    largest_stake = max((b["stake_usdc"] for b in active_bets), default=0)
    largest_pct = (largest_stake / capital * 100) if capital > 0 else 0

    if total_exposure > 0:
        stakes = [b["stake_usdc"] for b in active_bets]
        hhi = sum((s / total_exposure) ** 2 for s in stakes)
    else:
        hhi = 0

    if hhi < 0.15:
        concentration = "Low ğŸŸ¢"
    elif hhi < 0.25:
        concentration = "Medium ğŸŸ¡"
    else:
        concentration = "High ğŸ”´"

    return f"""## âš–ï¸ Portfolio Risk Metrics

| Metric | Value |
|--------|-------|
| Total Exposure | ${total_exposure:.2f} ({exposure_pct:.1f}% of capital) |
| Avg Position Size | ${avg_position:.2f} |
| Largest Position | ${largest_stake:.2f} ({largest_pct:.1f}%) |
| Portfolio Concentration | {concentration} (HHI: {hhi:.3f}) |

---
"""


def _generate_active_bets_section(all_active_display, now_cet):
    active_rows = _build_active_rows(all_active_display, now_cet)
    if active_rows:
        active_table = "\n".join(active_rows)
    else:
        active_table = "| *No active bets* | - | - | - | - | - | - | - | - | - | - |"

    return f"""## ğŸ¯ Active Bets ({len(all_active_display)})

| Question | Action | Stake | Market | AI Prob | Edge | Conf | EV | End Date | Days Left | Status |
|---|---|---|---|---|---|---|---|---|---|---|
{active_table}

ğŸ“Š **[View Detailed AI Analysis â†’](AI_DECISIONS.md)**

---
"""


def _build_active_rows(all_active_display, now_cet):
    active_rows = []
    for bet in all_active_display:
        q_display = _format_question_link(bet)
        stake, price, ai_prob, edge, conf, ev = _extract_bet_metrics(bet)
        edge_ind = _get_edge_indicator(edge)
        end_date_display, days_display, status = _get_bet_status(bet, now_cet)

        active_rows.append(
            f"| {q_display} | {bet['action']} | ${stake:.2f} | {price:.2f} | "
            f"{ai_prob:.2f} | {edge:+.0%} {edge_ind} | {conf:.0%} | ${ev:+.2f} | "
            f"{end_date_display} | {days_display} | {status} |"
        )
    return active_rows


def _format_question_link(bet):
    q_text = bet["question"]
    if len(q_text) > 40:
        q_text = q_text[:40] + "..."
    url_slug = bet.get("url_slug") or bet.get("market_slug")
    url = f"https://polymarket.com/event/{url_slug}"
    return f"[{q_text}]({url})"


def _extract_bet_metrics(bet):
    stake = float(bet["stake_usdc"])
    price = float(bet["entry_price"])
    ai_prob = float(bet["ai_probability"]) if bet["ai_probability"] is not None else 0.0
    edge = float(bet["edge"]) if bet["edge"] is not None else 0.0
    conf = float(bet["confidence_score"]) if bet["confidence_score"] is not None else 0.0
    ev = float(bet["expected_value"])
    return stake, price, ai_prob, edge, conf, ev


def _get_edge_indicator(edge):
    if edge >= 0.20:
        return "ğŸŸ¢"
    elif edge >= 0.10:
        return "ğŸŸ¡"
    return "ğŸ”´"


def _get_bet_status(bet, now_cet):
    end_date_val = bet.get("end_date")
    end_date_display = "Unknown"
    days_display = "N/A"
    status = "ğŸ”µ"

    if end_date_val:
        try:
            ed_cet = to_cet(end_date_val)
            if ed_cet:
                days_left = (ed_cet - now_cet).days
                end_date_display = ed_cet.strftime("%Y-%m-%d")
                days_display = f"{days_left}d"
                status = _calculate_status_icon(days_left, bet.get("status"))
        except Exception:
            pass

    if bet.get("status") == "PENDING_RESOLUTION" and "Pending Resolution" not in status:
        status = "â³ Pending Resolution"

    return end_date_display, days_display, status


def _calculate_status_icon(days_left, bet_status):
    if days_left < 0:
        if bet_status == "PENDING_RESOLUTION":
            return "â³ Pending Resolution"
        else:
            return "â° Expired"
    elif days_left < 3:
        return "ğŸ”´"
    elif days_left < 7:
        return "ğŸŸ¡"
    else:
        return "ğŸŸ¢"


def _generate_alerts_section(rpm_pct, rpd_pct, tpm_pct, active_bets, capital, now_cet):
    alerts = []
    alerts.extend(_check_api_limits(rpm_pct, rpd_pct, tpm_pct))
    alerts.extend(_check_high_exposure(active_bets, capital))
    alerts.extend(_check_expiring_soon(active_bets, now_cet))

    if not alerts:
        alerts.append("ğŸŸ¢ **No critical issues detected**")

    return f"""## âš ï¸ Alerts & Warnings

{chr(10).join(f"- {a}" for a in alerts)}

---
"""


def _check_api_limits(rpm_pct, rpd_pct, tpm_pct):
    alerts = []
    if rpm_pct >= 90:
        alerts.append(f"ğŸ”´ **API Limit Warning**: Gemini RPM at {rpm_pct:.0f}% capacity")
    if rpd_pct >= 90:
        alerts.append(f"ğŸ”´ **API Limit Warning**: Gemini RPD at {rpd_pct:.0f}% capacity")
    if tpm_pct >= 90:
        alerts.append(f"ğŸ”´ **API Limit Warning**: Gemini TPM at {tpm_pct:.0f}% capacity")
    return alerts


def _check_high_exposure(active_bets, capital):
    alerts = []
    for bet in active_bets:
        pos_pct = (float(bet["stake_usdc"]) / capital * 100) if capital > 0 else 0
        if pos_pct > 10:
            alerts.append(f"ğŸ”´ **High Exposure**: \"{bet['question'][:30]}...\" is {pos_pct:.1f}% of capital")
    return alerts


def _check_expiring_soon(active_bets, now_cet):
    alerts = []
    expiring_soon = 0
    for bet in active_bets:
        if bet.get("end_date"):
            try:
                ed_cet = to_cet(bet["end_date"])
                if ed_cet:
                    days = (ed_cet - now_cet).days
                    if 0 <= days <= 7:
                        expiring_soon += 1
            except Exception:
                pass
    if expiring_soon > 0:
        alerts.append(f"ğŸŸ¡ **Expiring Soon**: {expiring_soon} bet(s) expire within 7 days")
    return alerts


def _generate_market_insights(all_active_display):
    markets_analyzed = os.getenv("TOP_MARKETS_TO_ANALYZE", "15")
    markets_with_bets = len(all_active_display)
    recent_rejections = database.get_rejected_markets(limit=20)
    rejection_counts = {}
    for rej in recent_rejections:
        reason = rej["rejection_reason"]
        rejection_counts[reason] = rejection_counts.get(reason, 0) + 1

    top_rejection = max(rejection_counts.items(), key=lambda x: x[1])[0] if rejection_counts else "N/A"

    return f"""## ğŸ“Š Market Insights

| Metric | Value |
|--------|-------|
| Markets Analyzed per Run | {markets_analyzed} |
| Markets with Active Bets | {markets_with_bets} |
| Markets Rejected (Last Run) | {len(recent_rejections)} |
| Top Rejection Reason | {top_rejection} |

ğŸ“‹ **[View All Rejected Markets â†’](AI_DECISIONS.md#rejected-markets)**

---
"""


def generate_advanced_analytics_section(results: list) -> str:
    """Generiert erweiterte Analytics Section."""
    if len(results) < 5:
        return """## ğŸ“Š Advanced Analytics\n\n*Insufficient data (need at least 5 closed bets)*\n\n---\n"""
    try:
        from src import analytics_advanced

        calibration_section = _generate_calibration_section(analytics_advanced, results)
        edge_section = _generate_edge_section(analytics_advanced, results)
        trends_section = _generate_trends_section(analytics_advanced, results)
        dd_section = _generate_drawdown_section(analytics_advanced, database)

        return calibration_section + edge_section + trends_section + dd_section + "\n---\n"
    except Exception as e:
        logger.error(f"Error generating advanced analytics: {e}")
        return "\n*Advanced analytics unavailable*\n\n---\n"


def _generate_calibration_section(analytics_advanced, results):
    calibration = analytics_advanced.calculate_confidence_calibration(results)
    section = """## ğŸ¯ AI Confidence Calibration

| Confidence Range | Predicted | Actual | Bets | Error | Status |
|------------------|-----------|--------|------|-------|--------|
"""
    for bucket in calibration["buckets"]:
        if bucket["num_bets"] == 0:
            section += f"| {bucket['range']} | - | - | 0 | - | Insufficient data |\n"
        else:
            pred = f"{bucket['predicted_win_rate']:.1%}"
            actual = f"{bucket['actual_win_rate']:.1%}" if bucket["actual_win_rate"] else "N/A"
            error = f"{bucket['calibration_error']:+.1%}" if bucket["calibration_error"] else "N/A"
            status = bucket["status"]
            icon = "âœ…" if status == "well_calibrated" else "âš ï¸" if status == "acceptable" else \
                ("ğŸ”´" if status == "overconfident" else ("ğŸ”µ" if status == "underconfident" else "âšª"))
            status_title = status.replace("_", " ").title()
            row = (
                f"| {bucket['range']} | {pred} | {actual} | {bucket['num_bets']} | "
                f"{error} | {icon} {status_title} |\n"
            )
            section += row

    overall = calibration["overall_calibration"]
    score_icon = "ğŸŸ¢" if overall >= 0.90 else "ğŸŸ¡" if overall >= 0.80 else "ğŸ”´"
    section += f"\n**Overall Calibration Score:** {overall:.1%} {score_icon}\n"
    return section


def _generate_edge_section(analytics_advanced, results):
    edge_val = analytics_advanced.calculate_edge_validation(results, min_bets=10)
    section = """\n## ğŸ“ Edge Validation Analysis

| Predicted Edge | Avg Pred | Avg Real | Delta | Accuracy | Bets |
|----------------|----------|----------|-------|----------|------|
"""
    for bucket in edge_val["buckets"]:
        if bucket["status"] == "insufficient_data":
            section += f"| {bucket['range']} | - | - | - | - | {bucket['num_bets']} (need 10+) |\n"
        else:
            pred = f"{bucket['avg_predicted_edge']:+.1%}"
            real = f"{bucket['avg_realized_edge']:+.1%}"
            delta = f"{bucket['delta']:+.1%}"
            acc = f"{bucket['accuracy']:.0%}"
            acc_icon = "âœ…" if bucket["accuracy"] >= 0.90 else "âš ï¸" if bucket["accuracy"] >= 0.80 else "ğŸ”´"
            section += f"| {bucket['range']} | {pred} | {real} | {delta} | {acc} {acc_icon} | {bucket['num_bets']} |\n"

    section += f"\n**Overall Edge Accuracy:** {edge_val['overall_accuracy']:.0%}\n"
    return section


def _generate_trends_section(analytics_advanced, results):
    trends = analytics_advanced.calculate_model_trends(results, window_days=30, num_periods=8)
    section = """\n## ğŸ“ˆ AI Model Performance Trends (30-day Rolling)

| Period | Win Rate | Avg Conf | Calibration | Bets |
|--------|----------|----------|-------------|------|
"""
    for period in trends["periods"]:
        section += (
            f"| {period['period_label']} | {period['win_rate']:.1%} | "
            f"{period['avg_confidence']:.0%} | {period['calibration_score']:.0%} | "
            f"{period['num_bets']} |\n"
        )

    trend_icons = {
        "improving": "ğŸ“ˆ Improving",
        "declining": "ğŸ“‰ Declining",
        "stable": "â¡ï¸ Stable",
        "insufficient_data": "âšª Insufficient data",
    }
    section += f"\n**Trend:** {trend_icons.get(trends['trend_direction'], 'Unknown')}\n"
    return section


def _generate_drawdown_section(analytics_advanced, database):
    capital_history = database.get_capital_history()
    dd_metrics = analytics_advanced.calculate_drawdown_metrics(capital_history)

    if dd_metrics.get("status") == "insufficient_data":
        return "\n## ğŸ“‰ Drawdown Analysis\n\n*Insufficient data*\n"

    status_icons = {"normal": "ğŸŸ¢", "warning": "ğŸŸ¡", "alert": "ğŸŸ ", "critical": "ğŸ”´"}
    status_icon = status_icons.get(dd_metrics["status"], "âšª")

    section = f"""
## ğŸ“‰ Drawdown Analysis

### Current Status: {status_icon} {dd_metrics['status'].upper()}

| Metric | Value |
|--------|-------|
| Current Drawdown | {dd_metrics['current_drawdown_pct']:.2%} |
| Days in Drawdown | {dd_metrics['current_drawdown_days']} days |
| Peak Capital | ${dd_metrics['peak_capital']:.2f} |
| Current Capital | ${dd_metrics['current_capital']:.2f} |
| Max Historical DD | {dd_metrics['max_historical_dd']:.2%} |
| Max DD Recovery Time | {dd_metrics['max_dd_recovery_days']} days |

**Recommendation:** {dd_metrics['recommendation']}
"""
    if dd_metrics["drawdown_periods"]:
        section += "### Historical Drawdown Periods\n\n"
        section += "| Start | End | Duration | Max DD | Recovery |\n"
        section += "|-------|-----|----------|--------|----------|\n"
        for period in dd_metrics["drawdown_periods"][:3]:
            section += (
                f"| {period['start_date']} | {period['end_date']} | "
                f"{period['duration_days']}d | {period['max_dd']:.2%} | "
                f"{period['recovery_days']}d |\n"
            )
    return section


def generate_chart_section(results):
    capital_history = [database.INITIAL_CAPITAL]
    running = database.INITIAL_CAPITAL
    sorted_res = sorted(
        results,
        key=lambda x: x["timestamp_closed"]
        or datetime.min.replace(tzinfo=timezone.utc),
    )
    for r in sorted_res:
        running += float(r["profit_loss"])
        capital_history.append(running)

    chart_data = capital_history[-30:]
    if len(chart_data) >= 2:
        try:
            chart = asciichartpy.plot(chart_data, {"height": 10})
        except Exception:
            chart = "Error generating chart."
    else:
        chart = "Insufficient data for chart (need at least 2 data points)."

    return f"""## ğŸ“Š Capital Performance (ASCII Chart)

```
{chart}
```

---
"""


def generate_recent_results_section(results):
    recent = sorted(
        results,
        key=lambda x: x["timestamp_closed"]
        or datetime.min.replace(tzinfo=timezone.utc),
        reverse=True,
    )[:10]
    if not recent:
        return """## ğŸ“œ Recent Results (Last 10)

*No results yet.*

---
"""

    rows = []
    for r in recent:
        ts = r["timestamp_closed"]
        ts_cet = to_cet(ts)
        date_str = ts_cet.strftime("%Y-%m-%d") if ts_cet else "N/A"
        icon = "âœ… WIN" if float(r["profit_loss"]) > 0 else "âŒ LOSS"
        rows.append(
            f"| {date_str} | {r['question']} | {r['action']} | {icon} | ${float(r['profit_loss']):+.2f} |"
        )

    return f"""## ğŸ“œ Recent Results (Last 10)

| Date | Question | Action | Outcome | P&L |
|---|---|---|---|---|
{chr(10).join(rows)}

---
"""


if __name__ == "__main__":
    generate_dashboard()
